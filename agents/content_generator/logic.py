"""
Content Generator Agent - Generates personalized learning content using Google AI SDK
"""
from typing import Dict, List, Any, Optional
from datetime import datetime
from utils.logger import setup_logger
from core.ai_client import get_ai_client

logger = setup_logger(__name__)

class ContentGenerator:
    def __init__(self):
        self.logger = setup_logger(__name__)
        self.ai_client = get_ai_client()
        # Fallback templates for when AI is unavailable
        self.topics = {
            "quadratic_factoring": {
                "lesson": "Quadratic factoring is a method to express a quadratic equation as a product of binomials. For example, x² - 5x + 6 = (x - 2)(x - 3).",
                "examples": [
                    "Factor x² + 7x + 10 = (x + 5)(x + 2)",
                    "Factor x² - 4x - 5 = (x - 5)(x + 1)"
                ],
                "practice_questions": [
                    "Factor: x² - 6x + 8",
                    "Factor: x² + x - 12"
                ]
            }
        }

    async def generate_lesson_content(
        self, 
        topic: str,
        difficulty: str = "beginner",
        student_profile: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Generate personalized lesson content for a given topic using Google AI SDK
        """
        try:
            self.logger.info(f"Generating lesson content for topic: {topic}, difficulty: {difficulty}")
            
            # Use Google AI SDK to generate content
            lesson_data = await self.ai_client.generate_lesson_content(topic, difficulty, student_profile)
            
            # Personalize based on student profile
            if student_profile:
                lesson_data = self._personalize_content(lesson_data, student_profile)
            
            self.logger.info(f"Successfully generated lesson content for {topic}")
            return lesson_data
            
        except Exception as e:
            self.logger.error(f"Error generating content with AI: {str(e)}. Falling back to template.")
            # Fallback to template-based content
            return self._generate_fallback_content(topic, difficulty, student_profile)

    def _generate_fallback_content(self, topic: str, difficulty: str, student_profile: Optional[Dict] = None) -> Dict[str, Any]:
        """Generate content using fallback templates when AI is unavailable"""
        template = self.topics.get(topic.lower().replace(" ", "_"))
        
        if template:
            content = template.copy()
            content.update({
                "title": f"{topic.title()} - {difficulty.title()} Level",
                "difficulty": difficulty,
                "generated_at": datetime.utcnow().isoformat(),
                "source": "template"
            })
        else:
            content = self._generate_dynamic_content(topic, difficulty)
        
        if student_profile:
            content = self._personalize_content(content, student_profile)
        
        return content

    def _generate_dynamic_content(self, topic: str, difficulty: str = "beginner") -> Dict[str, Any]:
        """Generate dynamic content when no template exists"""
        return {
            "title": f"{topic.title()} - {difficulty.title()} Level",
            "explanation": f"This is a comprehensive lesson on {topic} at {difficulty} level. This content would be generated by AI in production.",
            "examples": [
                f"Example 1 for {topic} ({difficulty} level)",
                f"Example 2 for {topic} ({difficulty} level)",
                f"Example 3 for {topic} ({difficulty} level)"
            ],
            "practice_questions": [
                f"Practice question 1 for {topic}",
                f"Practice question 2 for {topic}",
                f"Practice question 3 for {topic}",
                f"Practice question 4 for {topic}",
                f"Practice question 5 for {topic}"
            ],
            "key_takeaways": [
                f"Key concept 1 about {topic}",
                f"Key concept 2 about {topic}",
                f"Key concept 3 about {topic}"
            ],
            "real_world_applications": [
                f"Real-world application 1 of {topic}",
                f"Real-world application 2 of {topic}"
            ],
            "difficulty": difficulty,
            "generated_at": datetime.utcnow().isoformat(),
            "source": "dynamic_template"
        }

    def _personalize_content(self, content: Dict[str, Any], student_profile: Dict) -> Dict[str, Any]:
        """Personalize content based on student profile"""
        content["personalized"] = True
        content["learning_style"] = student_profile.get("learning_style", "visual")
        content["student_grade_level"] = student_profile.get("grade_level", "high school")
        
        # Add personalization metadata
        content["personalization_applied"] = datetime.utcnow().isoformat()
        
        return content

    async def generate_quiz_questions(self, topic: str, difficulty: str = "beginner", num_questions: int = 5) -> List[Dict[str, Any]]:
        """
        Generate quiz questions for a topic using Google AI SDK
        """
        try:
            self.logger.info(f"Generating {num_questions} quiz questions for {topic}")
            questions = await self.ai_client.generate_quiz_questions(topic, difficulty, num_questions)
            return questions
            
        except Exception as e:
            self.logger.error(f"Error generating quiz questions: {str(e)}")
            # Fallback questions
            return self._generate_fallback_questions(topic, difficulty, num_questions)
    
    def _generate_fallback_questions(self, topic: str, difficulty: str, num_questions: int) -> List[Dict[str, Any]]:
        """Generate fallback quiz questions when AI is unavailable"""
        questions = []
        for i in range(num_questions):
            questions.append({
                "type": "multiple_choice" if i % 2 == 0 else "short_answer",
                "question": f"Question {i+1} about {topic} ({difficulty} level)",
                "options": ["Option A", "Option B", "Option C", "Option D"] if i % 2 == 0 else None,
                "correct_answer": "Option A" if i % 2 == 0 else f"Sample answer for {topic}",
                "explanation": f"This explains why the answer is correct for {topic}",
                "difficulty_points": 3 if difficulty == "beginner" else 5 if difficulty == "intermediate" else 8,
                "topic": topic,
                "generated_at": datetime.utcnow().isoformat(),
                "source": "fallback"
            })
        return questions
